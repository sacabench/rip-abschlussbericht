\section{pSAIS}
\label{section:psais}

\currentauthor{Jonas Bode} 

Der pSAIS -- kurz für parallel SAIS -- ist ein SACA der sich aus dem SAIS entwickelt hat und mithilfe von parallel laufenden Threads ein Suffixarray berechnet \cite{psais}. Die grundlegende Idee des pSAIS ist es, das SA für das Induced Sorting zuerst in mehrere Blöcke aufzuteilen, mit Blockgröße $\beta$ (diese wurde in unserer Implementierung fest auf 10 MiB gesetzt). Für diese Blöcke kann die Methode des Induced Sortings dann teilweise parallelisiert werden.\\
Es werden Buffer-Listen $r$ und $w$ für das Lesen aus dem Text und das Schreiben in das SA  eingeführt, welche die selbe Länge $\beta$ haben und Tupel der Art $\langle chr, pos \rangle$ enthalten. In dem Lese-Buffer $r$ gibt $chr$ ein Zeichen des Textes und $pos$ seine Position im Text an. In dem Schreib-Buffer $w$ ist $chr$ eine Position im Text und $pos$ ist die Position des SAs, an welcher $chr$ eingeordnet werden soll. Für jeden Block $B$ werden dann die folgenden drei Phasen nacheinander durchgeführt:

\begin{itemize}
\item \textbf{Preparing:} Hier werden alle Paare $\langle chr, pos \rangle$ in einen Lese-Buffer $r$ hineingeschrieben, welche die Bedingung erfüllen, dass $pos = B[j]-1$ ist, für ein Position $j$ von Block $B$. Je nachdem um welches Induce Sorting es sich handelt muss $T[pos]$ außerdem ein L- bzw. S-Typ sein. Das gesamte Preparing wird hierbei \textbf{parallel} für jede Stelle $j$ des Blocks $B$ aufgerufen. Das Preparing lädt also bestimmte Zeichen in den Lese-Buffer, welche dann in dem folgenden Schritt effizient und ohne direkt auf den Text zugreifen zu müssen herausgelesen werden können.

\item \textbf{Inducing:} Das Induzieren folgt auf das Preparing des Blockes $B$. Es erfolgt \textbf{nicht parallel} und benutzt den vorher beschriebenen Read-Buffer $r$. Block $B$ wird durchlaufen und für jede Position $i$ in $B$ wird wie beim Induced Sorting überprüft, ob $chr = B[i]-1$ ein L- bzw. ein S-Typ ist. Falls dem so ist, wird die in $r[i].chr$ gespeicherte Information benutzt um direkt das passende Zeichen zu dieser Position zu erhalten. Ist $r[i]$ leer -- dies kann z.B. passieren wenn $B[i]-1$ gar nicht mehr in Block $B$ hineingehört -- wird stattdessen das Zeichen aus dem Text gelesen, also $T[B[i]-1]$. Danach wird zu dem gelesenen Zeichen die passende Position $pos$ für $chr$ im SA gesucht und das Tupel $\langle chr, pos \rangle$ wird in einen Schreib-Buffer $w$ eingefügt, falls $pos$ in den Bereich des momentanen Blocks $B$ oder den des darauffolgenden Blocks $B^\prime$ fällt. Fällt $pos$ nicht in den Bereich von einen der beiden Blöcke wird direkt in das SA geschrieben: $SA[pos] = chr$.

\item \textbf{Updating:} Im Updating wird \textbf{parallel} der Schreib-Buffer $w$ durchlaufen und für jedes Paar $\langle chr, pos \rangle$ in $w$ wird $SA[pos] = chr$ gesetzt. Das Updating hilft, genau wie das Preparing, die Zugriffe auf das SA bzw. den Eingabetext effizienter zu machen, da anderfalls bei direkten Zugriffen viele Cache Misses entstehen können.
\end{itemize}

Diese drei Stufen, welche wir das \textbf{Pipelined Inducing} nennen, ersetzen vollständig das Induzieren im pSAIS. Wird SA in die Blöcke $B_1, \ldots, B_k$ eingeteilt, so müssen für das Induzieren der L-Typen die Blöcke in der angegebenen Reihenfolge durchlaufen werden, für das Induzieren der S-Typen müssen sie jedoch in umgekehrter Reihenfolge durchlaufen werden. Beispielhaft stellen wir dafür im Folgenden nur das Pipelined Inducing der L-Typen dar, da sich das Pipelined Inducing der S-Typen analog daraus ergibt.


