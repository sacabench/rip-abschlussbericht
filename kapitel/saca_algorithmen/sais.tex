\section{SAIS}
\subsection{Framework}
\label{saisAlg}
\currentauthor{Christopher Poeplau}
\begin{minted}[mathescape=true, escapeinside=||, frame=single]{text}
SA-IS(|$T$|,|$SA$|)
    //|$T$| is the input string;
    //|$SA$| is the output suffix array of |$T$|
    |$t$|: array[|$0..n-1$|] of boolean;
    |$P_1$|, |$T_1$|: array[|$0..n_1-1$|] of integer; //|$n_1=\Vert S_1 \Vert$|
    B: array[|$0..\Vert \Sigma (T)\Vert-1$|] of integer;
1   Scan |$T$| once to classify all the characters as L- or S-type
    into |$t$|;
2   Scan |$t$| once to find all the LMS-substrings in |$T$| into |$P_1$|;
3   Induced sort all the LMS-substrings using |$P_1$| and |$B$|;
4   Name each LMS-substring in |$T$| by its bucket index to get a
    new shortened string |$T_1$|;
6   if Each character in |$T_1$| is unique
7       then
8           Directly compute |$SA_1$| from |$T_1$|;
9       else
10          SA-IS(|$T_1$|,|$SA_1$|); //Fire a recursive call
11  Induce |$SA$| from |$SA_1$|
12  return
\end{minted}
Der oben stehende Algorithmus~\cite[fig.~1]{saca:6} berechnet das Suffix-Array des Strings $T$. Grundsätzlich ist das Problem in zwei Teile aufgeteilt. Das Reduzieren des Problems zu Teilproblemen (Divide and Conquer) und das Induzieren der LMS-Substrings und der Teilsuffix-Arrays. Am deutlichsten wird die Funktionsweise des Algorithmus durch ein Beispiel.

\subsection{Verfahren}
Sei $T=caabaccaabacaa\$$ der String zu dem das Suffix-Array konstruiert werden soll und $SA$ das zugehörige Suffix-Array. Zunächst wird für jedes Zeichen des Strings $T$ der Typ $t$, nach den Definitionen aus Kap.~\ref{section:induzierer}, ermittelt.

\begin{center}
  \begin{tabular}{ | l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
    \hline
        $i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 \\ \hline
        $T$ & c & a & a & b & a & c & c & a & a & b & a & c & a & a & \$ \\ \hline
        $t$ & L & S & S & L & S & L & L & S & S & L & S & L & L & L & S \\
    \hline
  \end{tabular}
\end{center}
\bigskip
Der nächste Schritt besteht daraus, alle LMS-Substrings zu finden. Besonders am SAIS ist, dass die LMS-Substrings eine variable Länge besitzen. Diese Länge wird beim später beschriebenen SADS beschränkt. Diese Schritte besitzen eine obere Laufzeitschranke von $\mathcal{O}(n)$, da ein einmaliger Durchlauf von rechts nach links ausreicht, um alle Typen(L, S und LMS) zu bestimmen.

\noindent Für die LMS variabler Länger ergibt sich folgende Berechnung, wobei der Anfang des LMS durch einen Stern gekennzeichnet ist. Das Ende des LMS-Substrings ergibt sich aus dem nächstfolgenden Stern bzw. dem Ende des Wortes.

\begin{center}
  \begin{tabular}{ | l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
    \hline
        $i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 \\ \hline
        $T$ & c & a & a & b & a & c & c & a & a & b & a & c & a & a & \$ \\ \hline
            & L & S & S & L & S & L & L & S & S & L & S & L & L & L & S \\ \hline
            &   & * &   &   & * &   &   & * &   &   & * &   &   &   & * \\
    \hline
  \end{tabular}
\end{center}
\bigskip
Nachdem die LMS-Substrings bestimmt sind, folgt das Unterteilen in Buckets und Buckettypen. Die verschiedenen im Text vorkommenden Zeichen bilden die  $Basisbuckets$. Jeder dieser $Basisbuckets$ ist außerdem in einen L- und einen S-Teil aufgeteilt. Der L-Teil eines Buckets steht immer vor dem S-Teil eines Buckets. Außerdem ist die Bucketgröße proportional zu der entsprechenden Anzahl der im Text vorkommenden Zeichen. Die Buckets selbst sind lexikographisch sortiert.

\begin{center}
  \begin{tabular}{ | l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
    \hline
        $i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 \\ \hline
        $T$ & c & a & a & b & a & c & c & a & a & b & a & c & a & a & \$ \\ \hline
            & L & S & S & L & S & L & L & S & S & L & S & L & L & L & S \\ \hline
            &   & * &   &   & * &   &   & * &   &   & * &   &   &   & * \\ \hline
   $Bucket$ &\$ & \multicolumn{7}{c}{a} &   & \multicolumn{1}{c}{b} &   & \multicolumn{3}{c}{c} & \\ \hline
      $Typ$ & S & \multicolumn{1}{c}{L} &   & \multicolumn{5}{c}{S} &   & \multicolumn{1}{c}{L} &    & \multicolumn{3}{c}{L} &\\
    \hline
  \end{tabular}
\end{center}
\bigskip

\noindent Die zugrundeliegenden LMS-Substrings müssen im nächsten Schritt sortiert werden. \\
\noindent Problem: Sortiere LMS-Substrings $\{14, 10, 7, 4, 1\}$ \\

\noindent Es ergibt sich also folgende Konstellation:

\begin{center}
	\begin{tabular}{c|c|c|c|c}
			 1 	     &            4          &          7            &           10            &          14 \\
          	aaba     &          acca         &        aaba           &          acaa\$         &          \$  \\
         	SSLS     &          SLLS         &        SSLS           &          SLLLS          &           S
	\end{tabular}
\end{center}
\bigskip

\noindent Durch das Vergleichen der jeweiligen Zeichen und Typen kann so folgende Reihenfolge berechnet werden: $\{14, \textcolor{red}{7}, \textcolor{red}{1}, 10, 4\}$ \\
\noindent Problem: Dadurch, dass die Substrings identisch sind, ist noch keine eindeutige Reihenfolge entstanden. Es muss ein weiterer Rekursionsschritt durchgeführt werden.

\newpage \noindent Analog zum Anfang werden den Substrings Buckets zugeordnet:

\begin{center}
  \begin{tabular}{ | l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
    \hline
        $T_1$ & 1 & 3 & 1 & 2 & 0 \\ \hline
              & 1 & 4 & 7 & 10 & 14  \\
    \hline
  \end{tabular}
\end{center}
\bigskip

\noindent Die Zahlen $1$ und $7$ werden demselben Bucket zugeordnet, da diese noch nicht sortiert werden konnten. Analog dazu wird der 14 der $kleinste$ Bucket zugeordnet, da das $\$$-Zeichen das lexikographisch kleinste Zeichen ist. Auf den so gewonnenen String $T_1$ wird nun der SAIS angewendet. Zunächst werden die LMS-Indizes $\{4, 2\}$ ihren $S-Buckets$ zugeordnet. Es folgt eine Iteration von links nach rechts. Entspricht das Vorgängerzeichen Typ $L$, wird es an der nächst linken freien Position des jeweiligen Buckets eingeordnet. Anschließend folgt eine Iteration von rechts nach links, bei der das Vorängerzeichen an der nächst rechten freien Position einsortiert wird, wenn es vom Typ $S$ ist.

\begin{center}
  \begin{tabular}{ | l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
    \hline
          & \tiny{1} & \tiny{4} & \tiny{7} & \tiny{10} & \tiny{14} \\ \hline
      $i$ & 0 & 1 & 2 & 3 & 4  \\ \hline
    $T_1$ & 1 & 3 & 1 & 2 & 0  \\ \hline
      $t_1$ & S & L & S\textsuperscript{*} & L & S\textsuperscript{*}  \\ \hline
$Buckets$ & 0 & \multicolumn{1}{c}{1} & & 2 & 3 \\ \hline
          & S & \multicolumn{1}{c}{S} & & L & L \\ \hline
          & 4 & & \textcolor{red}{2} & 3 & 1 \\ \hline
          & & 2 & 0 & & \\
    \hline
  \end{tabular}
\end{center}
\bigskip

\noindent Es ist zu beachten, dass die rot markierte $2$ im zweiten Durchlauf von der $0$ überschrieben wird, im nächsten Schritt aber direkt wieder von der $3$ induziert wird. \\
Das Ergebnis des Induzierens ist das Suffix-Array $SA_1 = \{4, 2, 0, 3, 1\}$. Damit kann auf die ursprüngliche Reihenfolge geschlossen werden. Demnach ist das sortierte LMS-Array: $\{14, 7, 1, 10, 4\}$ \\
Die Rekursionstiefe von $1$ ändert sich wieder auf die Tiefe von $0$ und das ursprüngliche Problem wird gelöst, da jetzt die Reihenfolge eindeutig bestimmt ist. Analog zum Rekursionsschritt, werden zunächst die LMS-Indizes in die jeweiligen $S-Buckets$ einsortiert, um dann durch eine links-rechts und rechts-links-Iteration das Suffix-Array $SA$ zu berechnen:

\begin{center}
  \begin{tabular}{ | l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
    \hline
        $i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 \\ \hline
        $T$ & c & a & a & b & a & c & c & a & a & b & a & c & a & a & \$ \\ \hline
            & L & S & S & L & S & L & L & S & S & L & S & L & L & L & S \\ \hline
            &   & * &   &   & * &   &   & * &   &   & * &   &   &   & * \\ \hline
   $Bucket$ &\$ & \multicolumn{7}{c}{a} &   & \multicolumn{1}{c}{b} &   & \multicolumn{3}{c}{c} & \\ \hline
      $Typ$ & S & \multicolumn{1}{c}{L} &   & \multicolumn{5}{c}{S} &   & \multicolumn{1}{c}{L} &    & \multicolumn{3}{c}{L} &\\ \hline
            & 14 & & & 7 & 1 & \textcolor{red}{10} & \textcolor{red}{4} & & &  &   & &   &   &  \\ \hline
            & & 13 & & & & & & & & 9 & 3 & & 6 & 0 & \\ \hline
            &  &  & 12 & & & & & & & & & & &  & 5 \\ \hline
            & & & & & &   & & &   &   & & 11 & & & \\ \hline
            & & & & & & 8 & 2 & 10 & 4 &   & &   &   &   & \\
    \hline
  \end{tabular}
\end{center}
\bigskip
Von links nach rechts ergibt sich das endgültige Suffix-Array \\
$SA = \{14, 13, 12, 7, 1, 8, 2, 10, 4, 9, 3, 11, 6, 0, 5\}$.

\subsection{Optimierung und Ausblick}
Der SAIS benötigt nur noch an zwei Stellen Extra-Speicher. Zum einen benötigen die Buckets zusätzlichen Speicher in Größe der Alphabetgröße. Zum anderen benötigt der SAIS einen Bitvektor, um die L- und S-Typen zu speichern. Alle anderen Berechnungen geschehen "on the fly", benötigen also keinen Extra-Speicher. So können die LMS-Typen leicht berechnet werden, indem sich vom aktuellen Typ des Zeichens der Vorgänger angeschaut wird. Wenn dieser vom Typ L ist, dann ist das Zeichen ein LMS. Im Zuge des nächsten Semesters sollen auch die Berechnungen der Typen "on the fly" geschehen, sodass der Bitvektor wegfällt. Aufwändig an dieser Stelle ist, dass momentan noch geteilte Schleifen, die das Wort von rechts nach links bzw. von links nach rechts durchlaufen kompaktifiziert werden müssen, damit die Typen, die berechnet wurden für alle Berechnungsschritte genutzt werden können. Interessant an dieser Stelle ist der Kompromiss zwischen Laufzeit und Extra-Speicher. Der Algorithmus kann auf Grund des Designs unseres Frameworks nicht nur für 8-Bit, sondern auch für 16-, 32-, 48-Bittypen usw. ausgeführt werden.

\newpage































