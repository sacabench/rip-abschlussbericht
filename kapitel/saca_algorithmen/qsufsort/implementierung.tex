\subsection{Implementierung}
\label{qsufsort:impl}
\subsubsection{Naive Variante}
Der qSufSort wurde zunächst in seiner naiven Variante implementiert, also ohne die von den Autoren vorgeschlagenen Verbesserungen aus Kapitel \ref{qsufsort:improv}. Der Algorithmus bekommt, wie auch die anderen implementierten Algorithmen innerhalb des Frameworks, den Text \mintinline{cpp}{text}, das dazugehörige Alphabetobjekt \mintinline{cpp}{alphabet} und das bereits allokierte Outputarray \mintinline{cpp}{out_sa} übergeben. Für den übergebenen Text wird vom Algorithmus gefordert, dass dieser mit genau einem Senitel Symbol endet. Darüber hinaus wird das letzte Bit eines Wertes reserviert um auch negative Zahlen darstellen zu können.

Zu Beginn wird überprüft, ob der Text mindestens zwei Zeichen beinhaltet, falls nicht, terminiert der Algorithmus trivialerweise. Andernfalls werden zunächst die beiden Hilfsarrays $\mathsf{V}$ und $\mathsf{L}$ allokiert. Mit Hilfe des ternary Quicksort wird dann der Text anhand des ersten Zeichens sortiert. Die daraus resultierende Sortierung wird in \mintinline{cpp}{out_sa} gespeichert. Darauf aufbauend werden dann die Inhalte der Hilfsarrays initialisiert. Der Präfixzähler $h$ wird auf 1 gesetzt und die Prefix-Doubling Phase startet. 

Dabei wird die Variable \mintinline{cpp}{counter} verwendet, die den aktuell betrachteten Index in \mintinline{cpp}{out_sa} speichert. Beginnt an dieser Stelle eine sortierte Gruppe, ist also der Eintrag im $\mathsf{L}$ Array negativ, überspringen wir diese, indem wir den aktuellen Counter \mintinline{cpp}{counter} um die Länge dieser Gruppe inkrementieren. Andernfalls handelt es sich um eine unsortierte Gruppe, die wir wieder mit Hilfe des Ternary Quicksort sortieren. Auf Basis dieser Sortierung aktualisieren wir dann die Gruppennummern.

Ist \mintinline{cpp}{counter} größer als die Länge von \mintinline{cpp}{out_sa}, terminiert die Schleife und wir aktualisieren die Gruppenlängen, verdoppeln $h$ und überprüfen dann anhand der Länge der ersten sortierten Gruppe, ob das Array komplett sortiert ist. Ist dem so, terminiert der Algorithmus und in \mintinline{cpp}{out_sa} steht das fertig sortierte Suffix-Array. Andernfalls wird die Schleife erneut durchlaufen, bis das Array komplett sortiert ist.

\subsubsection{Optimierung}
Ausgehend von der naiven Implementierung, wurden die von Autoren vorgeschlagenen praktischen Verbesserungen implementiert. 

Durch die erste Verbesserung, die Reduzierung auf ein Hilfsarray, konnte das zusätzliche Hilfsarray $\mathsf{L}$ eingespart werden. Stattdessen mussten die negativen Längen der sortierten Gruppen im Ausgabearray \mintinline{cpp}{out_sa} gespeichert werden. Da dieses innerhalb des Frameworks aus \mintinline{text}{unsigned int} besteht, wurde das letzte Bit vom Algorithmus reserviert, und falls nötig mit einer Bitmaske überschrieben, um \glqq negative\grqq{} Werte darzustellen. Das nach Terminierung des Prefix-Doublings errechnete ISA wurde dann mit der simplen ISAtoSA Variante ins Array \mintinline{cpp}{out_sa} invertiert. 

Die zweite Verbesserung, die Kombination von Sortieren und Updaten, ersetzt den expliziten Aufruf des ternary Quicksort innerhalb des Prefix-Doublings durch eine Funktion, die selbst die Partitionsfunktion des ternary Quicksort aufruft um die resultierenden Intervallgrenzen der Equal-Partition zum Updaten der Gruppen nutzen zu können.

Die dritte und letzte Verbesserung, die Beschleunigung der initialen Sortierung mit Hilfe von Wordpacking, transformiert nach Aufruf des Algorithmus den Text in das Ausgabearray \mintinline{cpp}{out_sa}, da das Textobjekt unveränderbar ist. Die resultierende Transformation wird dann, anders als von den Autoren vorgeschlagen, mit Hilfe des ternary Quicksort anstatt eines Bucketsort sortiert. Gründe dafür sind zum einen, da dieser unabhängig von der resultierenden Alphabetgröße durch das Wordpacking funktioniert und zum anderen Evaluierungen innerhalb unseres Frameworks gezeigt haben, dass dieser in diesem Fall die beste Laufzeit bietet.
