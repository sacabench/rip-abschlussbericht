\subparagraph*{Theorem 7 - alles zusammen}

In diesem Abschnitt stellen wir einen parallelen Mergealgorithmus vor, der effizient für eine konstante Anzahl an Threads $p$ arbeitet. Dieser Algorithmus wurde zuerst in (TODO: Valiant-Referenz) beschrieben und die Beschreibung wurde in (TODO: Kruskal) weiter ergänzt. Dazu seien $A$ und $B$ die Eingabearrays, die in das Ausgabearray $C$ gemergt werden sollen, mit $|A|=n$, $|B|=m$ und $|C|=n+m$.

Im Folgenden wird zunächst eine Übersicht über die Schritte des Algorithmus gegeben. Dieser Algorithmus arbeitet in sieben Schritten. In den ersten beiden Schritten werden insgesamt $p$ Elemente in $A$ und $B$ markiert und die Reihenfolge dieser Elemente in $C$ werden durch Mergen bestimmt. Durch die Wahl der markierten Elemente werden $A$ und $B$ in einzelne Segmente aufgeteilt. Um die markierten Elemente an die korrekten Positionen in $C$ schreiben zu können, benötigen wir für jedes markierte Element $x$ in $A$ die Position von $x$ in $A$ und die Position von $x$ in $B$ und analog für markierte Elemente aus $B$. Diese Positionen werden in den Schritten drei und vier bestimmt und die markierten Elemente an die korrekten Positionen in $C$ geschrieben.
In den letzten drei Schritten werden die übrigen Elemente in $A$ und $B$ gemergt, indem zunächst die Subsegmente in $A$ und $B$ bestimmt werden, die an die freien Stellen in $C$ gemergt werden sollen. Diese werden dann mit (TODO: Mergen von zwei Seiten) gemergt.

Nun werden die einzelnen Schritte genauer beschrieben. Im ersten Schritt markieren wir höchstens $p$ Elemente in $A$ und $B$ in jeweils gleichen Abständen. Als Abstände $d$ setzen wir $d = \lceil \frac{m+n}{p} \rceil$ und die markierten Elemente $x_i$ sind dann an den Positionen $i*d-1$ mit $i = 0,...p-1$. Markierte Elemente werden durch ein Tupel $(p_a, b, c)$ repräsentiert und in Arrays $\text{marked_element_A}$ geschrieben, wenn x_i in $A$ steht, bzw. $\text{marked_element_B}$, wenn $x_i$ in $B$ steht. Mit $p_a$ repräsentieren wir die Position des markierten Elements im eigenen Array, $b$ ist ein Indikator, wobei $b = 0$, wenn $x_i$ in $A$ steht und $b = 1$, wenn $x_i$ in $B$ steht und $c$ repräsentiert die Nummer des markierten Elements im eigenen Array. Diese Werte werden benötigt, damit diese Informationen nach dem Mergen der markierten Elemente direkt bereit stehen.
(TODO: Beispiel)

Im zweiten Schritt werden nun die markierten Elemente in $\text{marked_element_A}$ und in $\text{marked_element_B}$ in ein Array $\text{marked_element}$ gemergt. Dabei wird der Mergealgorithmus in (TODO: Referenz auf Johannes) verwendet. Da es höchstens $p$ markierte Elemente gibt, sind die Vorraussetzungen gegeben, um diesen Algorithmus anwenden zu können.
(TODO: Beispiel)

Jetzt müssen wir zu jedem markierten Element $x$ die Positionen $p_A$ in $A$ und $p_B$ in $B$ bestimmen. Um die folgenden beiden Schritte einfacher beschreiben zu können, nehmen wir an, dass $x$ ein markiertes Element aus $A$ ist. Für markierte Elemente aus $B$ sind die Schritte analog.
Sei dazu $x$ ein markiertes Element aus $A$. Die Position $p_A$ ist dann trivialerweise die Position an der $x$ in $A$ steht. Dies haben wir an der ersten Stelle im Tupel von $x$ gespeichert. Um die Position $p_B$ bestimmen zu können, müssen wir in $B$ nach der Position suchen, an der $x$ in $B$ stehen würde. Damit wir uns eine Suche über das ganze Array $B$ ersparen, nutzen wir die Ergebnisse aus Schritt zwei, um das Segment zu bestimmen in dem wir weiter nach $x$ suchen. 
Dazu betrachten wir die sortierte Reihenfolge der markierten Elemente aus Schritt zwei. Weiterhin betrachten wir ein markiertes Element aus $B$ der Form $(p_a, 1, p_m)$ und das darauf folgende markierte Element $(p'_a, 1, p'_m)$ aus $B$. Wir beobachten, dass alle markierten Elemente $(q_a, 0, q_m)$ aus $A$ im Segment zwischen den markierten Elementen $p_a$ und $p'_a$ in $B$ eingeordnet werden müssten. Mit dieser Beobachtung können wir nun parallel die Segmente aus $B$ bestimmen, in denen die markierten Elemente aus $A$ vorkommen und umgekehrt. Dazu erstellen wir zwei Hilfsarrays $pos_A$ und $pos_B$. In $pos_A$ speichern wir die Positionen der markierten Elemente in der sortierten Reihenfolge aus Schritt zwei und analog für $pos_B$. Da wir zu jedem markierten Element die Nummer des markierten Elements im Ursprungsarray speichern, können wir $pos_A$ und $pos_B$ direkt bestimmen. Anschließend betrachten wir zwei direkt aufeinanderfolgende Elemente $x=(p_a, 1, p_m)$ und $x'=(p'_a, 1, p'_m)$ in $pos_B$. Aus unserer Beobachtung können wir schließen, dass alle Elemente zwischen $x$ und $x'$ in der sortierten Reihenfolge aus Schritt zwei im Segment zwischen $x$ und $x'$ eingeordnet werden müssen. Daher können wir parallel für jedes dieser Elemente das Segment $[p_a+1, p'_a)$ speichern. (TODO: Sonderfälle). Analog lässt sich dieser Schritt für $pos_A$ durchführen.
(TODO: Beispiel)

Im vierten Schritt können wir nun für jedes markierte Element in dem in Schritt drei bestimmten Segment eine binäre Suche durchführen um die Position $p_B$ zu erhalten. Diese Position wird in einem Array $pos_in_other$ gespeichert, da wir diese Position im nächsten Schritt benötigen. Mit $p_A$ und $p_B$ lässt sich die Position der markierten Elemente in $C$ durch $p_A+p_B$ berechnen. 
(TODO: Beispiel)

Nach Schritt vier haben wir alle markierten Elemente an die korrekte Position in $C$ geschrieben (TODO: Überleitung zu Schritt 5)

