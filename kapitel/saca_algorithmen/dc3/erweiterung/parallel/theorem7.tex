\subparagraph*{Theorem 7 - alles zusammen}

In diesem Abschnitt stellen wir einen parallelen Mergealgorithmus vor, der effizient für eine konstante Anzahl an Threads $p$ arbeitet. Dieser Algorithmus wurde zuerst in \cite{merge:valiant} beschrieben und die Beschreibung wurde in \cite{merge:kruskal} weiter ergänzt. Dazu seien $A$ und $B$ die Eingabearrays, die in das Ausgabearray $C$ gemergt werden sollen, mit $|A|=n$, $|B|=m$ und $|C|=n+m$. \par
Wir werden den Algorithmus so erläutern, dass er mit einem beliebigen Vergleichsoperator arbeiten kann. Zur besseren Verständlichkeit verwenden wir in den Beispielen den Vergleichsoperator für natürliche Zahlen. In dem parallelen DC3 verwenden wir dann den bereits in \cref{dc3:algorithmus:phase3} beschriebenen Vergleichsoperator. 

Im Folgenden wird zunächst eine Übersicht über die Schritte des Algorithmus gegeben. Dieser Algorithmus arbeitet in sieben Schritten. In den ersten beiden Schritten werden insgesamt $p$ Elemente in $A$ und $B$ markiert und die Reihenfolge dieser Elemente in $C$ werden durch Mergen bestimmt. Durch die Wahl der markierten Elemente werden $A$ und $B$ in einzelne Segmente aufgeteilt. Um die markierten Elemente an die korrekten Positionen in $C$ schreiben zu können, benötigen wir für jedes markierte Element $x$ die Positionen in $A$ und in $B$. Diese Positionen werden in den Schritten drei und vier bestimmt und die markierten Elemente an die korrekten Positionen in $C$ geschrieben. \par
In den letzten drei Schritten werden die übrigen Elemente in $A$ und $B$ gemergt, indem zunächst die Subsegmente in $A$ und $B$ bestimmt werden, die an die freien Stellen in $C$ gemergt werden sollen. Diese werden dann mit der Parallelisierung aus \cref{dc3:erweiterung:parallel:mergezweiseiten} gemergt.

Nun werden die einzelnen Schritte genauer beschrieben. Im ersten Schritt markieren wir höchstens $p$ Elemente in $A$ und $B$ in jeweils gleichen Abständen. Als Abstände $d$ setzen wir $d = \lceil \frac{m+n}{p} \rceil$ und die markierten Elemente $x_i$ sind dann an den Positionen $i*d-1$. \par
Markierte Elemente werden durch ein Tupel $(p_a, b, c)$ repräsentiert und in Arrays $\texttt{marked\_element\_A}$ geschrieben, wenn $x_i$ in $A$ steht, bzw. $\texttt{marked\_element\_B}$, wenn $x_i$ in $B$ steht. \par
Mit $p_a$ repräsentieren wir die Position des markierten Elements im eigenen Array, $b$ ist ein Indikator, wobei $b = 0$, wenn $x_i$ in $A$ steht und $b = 1$, wenn $x_i$ in $B$ steht und $c$ repräsentiert die Nummer des markierten Elements im eigenen Array. Diese Werte werden benötigt, damit diese Informationen nach dem Mergen der markierten Elemente direkt bereit stehen. \par
In unserem Beispiel wollen wir die Arrays $A = [2,3,5,8,13,21,34]$ und $B = [4,9,16,25,36]$ mit vier Threads mergen. Der Abstand zwischen den Elementen ist $d = \frac{12}{4} = 3$. Wir markieren also in $A$ die Elemente $5$ und $21$ und in $B$ das Element $16$. Abgespeichert als Tupel sehen die markierten Elemente wie folgt aus: \par
$\begin{array}{ll}
$\texttt{marked\_element\_A}$= & $[(2,0,0), (5,0,1)]$ \\
$\texttt{marked\_element\_B}$= & $[(2,1,0)]$ \\
\end{array}$

Im zweiten Schritt werden nun die markierten Elemente in $\texttt{marked\_element\_A}$ und in $\texttt{marked\_element\_B}$ in ein Array $\texttt{marked\_element}$ gemergt. Dabei wird der Mergealgorithmus in (TODO: Referenz auf Johannes) verwendet. Da es höchstens $p$ markierte Elemente gibt, sind die Vorraussetzungen gegeben, um diesen Algorithmus anwenden zu können. \par
In unserem Beispiel werden $\texttt{marked\_element\_A}$ und $\texttt{marked\_element\_B}$ gemergt und als Ausgabe ergibt sich $\texttt{marked\_element} = [(2,0,0), (2,1,0), (5,0,1)]$. Dies entspricht der sortierten Reihenfolge der markierten Elemente $[5,16,21]$.

Jetzt müssen wir zu jedem markierten Element $x$ die Positionen $p_A$ in $A$ und $p_B$ in $B$ bestimmen. Um die folgenden beiden Schritte einfacher beschreiben zu können, nehmen wir an, dass $x$ ein markiertes Element aus $A$ ist. Für markierte Elemente aus $B$ sind die Schritte analog. \par
Sei dazu $x$ ein markiertes Element aus $A$. Die Position $p_A$ ist dann trivialerweise die Position an der $x$ in $A$ steht. Dies haben wir an der ersten Stelle im Tupel von $x$ gespeichert. Um die Position $p_B$ bestimmen zu können, müssen wir in $B$ nach der Position suchen, an der sich $x$ in $B$ einordnen lässt. Damit wir uns eine Suche über das ganze Array $B$ ersparen, nutzen wir die Ergebnisse aus Schritt zwei, um das Segment zu bestimmen in dem wir weiter nach $x$ suchen. 
Dazu betrachten wir die sortierte Reihenfolge der markierten Elemente aus Schritt zwei. Weiterhin betrachten wir ein markiertes Element aus $B$ der Form $x = (p_a, 1, c)$ und das darauf folgende markierte Element $x' = (p'_a, 1, c')$ aus $B$. Wir beobachten, dass alle markierten Elemente $(q_a, 0, e)$ aus $A$, die in der sortierten Reihenfolge zwischen $x$ und $x'$ stehen, im Segment zwischen den markierten Elementen $p_a$ und $p'_a$ in $B$ eingeordnet werden müssen. Mit dieser Beobachtung können wir nun parallel die Segmente aus $B$ bestimmen, in denen die markierten Elemente aus $A$ vorkommen und umgekehrt. \par
Dazu erstellen wir zwei Hilfsarrays $pos_A$ und $pos_B$. In $pos_A$ speichern wir die Positionen der markierten Elemente in der sortierten Reihenfolge aus Schritt zwei und analog für $pos_B$. Da wir zu jedem markierten Element die Nummer in $A$ bzw. $B$ speichern, können wir $pos_A$ und $pos_B$ direkt bestimmen. Anschließend betrachten wir zwei direkt aufeinanderfolgende Elemente $x=(p_a, 1, c)$ und $x'=(p'_a, 1, c')$ in $pos_B$. Aus unserer Beobachtung können wir schließen, dass alle Elemente zwischen $x$ und $x'$ in der sortierten Reihenfolge aus Schritt zwei im Segment zwischen $x$ und $x'$ eingeordnet werden müssen. Daher können wir parallel für jedes dieser Elemente das Segment $[p_a+1, p'_a)$ speichern. Analog lässt sich dieser Schritt für $pos_A$ durchführen. \par
In unserem Beispiel kommen die markierten Elemente von $A$ in der sortierten Reihenfolge an den Positionen $0$ und $2$ vor und das markierte Element von $B$ an der Position $1$. Also ist $pos_A = [0,2]$ und $pos_B = [1]$. Wir betrachten jetzt je zwei aufeinanderfolgende Elemente in $pos_A$, hier also $0$ und $2$. Dies bedeutet, dass in der sortierten Reihenfolge alle Elemente zwischen den Positionen $0$ und $2$ zum einen aus $B$ kommen und dass diese im Segment zwischen den dazugehörigen markierten Elementen liegen. Also können wir schließen, dass das markierte Element $16$ im Segment $[3, 5)$ in $A$ eingeordnet werden müsste. In $pos_B$ kommt nur das Element $1$ vor. Für alle Elemente, die davor oder dahinter in der sortierten Reihenfolge vorkommen, können wir dennoch das Segment bestimmen. Dazu ordnen wir dem ersten Element der sortierten Reihenfolge das Segment $[0,2)$ und dem letzten das Segment $[3,5)$ in $B$ zu.

Im vierten Schritt können wir nun für jedes markierte Element in dem in Schritt drei bestimmten Segment eine binäre Suche durchführen um die Position $p_B$ zu erhalten. Diese Position wird in einem Array $\texttt{pos\_in\_other\_A}$ gespeichert, da wir diese Position im nächsten Schritt benötigen. Mit $p_A$ und $p_B$ lässt sich die Position der markierten Elemente in $C$ durch $p_A+p_B$ berechnen. \par
Im Beispiel kommt das markierte Element $5$ in $A$ an der Position $2$ vor. Mittels einer binären Suche im Segment $[0,2)$ in $B$ können wir die Position $1$ berechnen, an der $5$ in $B$ eingeordnet werden müsste. Also müssen wir $5$ in $C$ an die Position $3$ schreiben. Das markierte Element $16$ steht in $B$ an der Position $2$ und mit einer binären Suche bestimmen wir die Position $5$ an der $16$ in $A$ eingeordnet werden müsste. In $C$ steht die $16$ also an der Position $7$. Für das markierte Element lässt sich analog die Position $8$ in $C$ berechnen. Unser Ausgabearray $C$ sieht nach diesem Schritt also wie folgt aus:

\begin{table}[H]
	\small
	\centering
	\begin{tabular}{c| c c c c c c c c c c c c c c c c c}
		$i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
		$C[i]$ & & & & 5 & & & & 16 & 21 & & & & \\
	\end{tabular}
\end{table}


Nach Schritt vier haben wir alle markierten Elemente an die korrekte Position in $C$ geschrieben. Nun müssen wir noch alle übrigen Elemente mergen. Wir haben nun in $C$ mehrere Segmente zwischen den markierten Elementen, die noch nicht beschrieben wurden. Wir beobachten, dass in einem freien Segment, welches durch $x$ und $x'$ induziert wird, nur diejenigen Elemente in $A$ und $B$ vorkommen können, die in $A$ und $B$ ebenfalls zwischen $x$ und $x'$ liegen. Durch die markierten Elemente und die in Schritt vier bestimmten Positionen der markierten Elemente im jeweils anderen Array ergibt sich somit eine Aufteilung in Subsegmente, die in ein freies Segment in $C$ gemergt werden sollen. \par
Im fünften Schritt werden wir also zunächst $A$ und $B$ in Subsegmente aufteilen. Dazu bestimmen wir zu Array $A$ die Positionen der markierten Elemente $\texttt{pos\_marked\_A}$ und mergen dies mit $\texttt{pos\_in\_other\_B}$ mit dem Mergealgorithmus aus (TODO: Referenz auf Johannes), um die Grenzen der Subsegmente zu erhalten. Daraus können wir die Subsegmente direkt bestimmen, da die Segmentgrenzen durch je zwei aufeinanderfolgende Positionen im gemergten Array gegeben sind. Hier ist zu beachten, dass die markierten Elemente nicht in einem Subsegment enthalten sein dürfen. \par
Im Beispiel sind die markierten Elemente von $A$ an den Positionen $[2,5]$ und das markierte Element $16$ von $B$l wurde in $A$ an die Position $[5]$ eingeordnet. Wenn wir beide Arrays mergen, ergibt sich das Array $[2,5,5]$, wobei die ersten beiden Elemente die markierten Elemente von $A$ sind. Nun bestimmen wir die Subsegmente von $A$. Dabei dürfen die markierten Elemente von $A$ nicht in den Subsegmenten enthalten sein. Die Subsegmente sind also $[[0,2), [3,5), [6,7)]$. Analog ergeben sich die Subsegmente von $B$ als $[[0,1), [1,2), [3,5)]$.

Nun wollen wir die einzelnen Subsegmente aus $A$ und $B$ parallel mit dem in \cref{dc3:erweiterung:parallel:mergezweiseiten} beschriebenen Algorithmus in die richtigen Segmente in $C$ mergen. Unser Ziel ist es, dass jeder Thread möglichst gleich viele Schritte beim Mergen benötigt. Dazu übernimmt jeder Thread ein Segment der Größe höchstens $s \le \lceil \frac{m+n}{p} \rceil$ in $A$ und $B$ und ist dafür zuständig $s$ Elemente zu mergen. Falls es in $A$ und $B$ Segmente gibt, die nicht durch ein markiertes Element beendet werden, werden beide durch ein Thread übernommen. \par
Wir berechnen zunächst für jeden Thread ein \textit{Schedule}. Ein Schedule ist eine Liste von \textit{Mergeaktionen}, die festlegen, welche Subsegmente gemergt werden und ob diese von links oder rechts gemergt werden sollen. Genauer ist eine Mergeaktion ein Tupel $(I_A, I_B, I_C, d, l)$, wobei $I_A$ ein Subsegment aus $A$, $I_B$ ein Subsegment aus $B$, $I_C$ ein freies Segment in $C$, in das $I_A$ und $I_B$ gemergt werden sollen. $d$ ist ein Indikator, wobei $d = 0$, wenn die Mergeschritte von links, und $d = 1$, wenn die Mergeschritte von rechts ausgeführt werden sollen und $l$ bezeichnet die Anzahl der Mergeschritte, die ausgeführt werden sollen. \par
Nun beschreiben wir wie ein solches Schedule berechnet werden kann. Wenn wir das $i$-te Subsegment $A_i$ und $B_i$ aus $A$ und $B$ betrachten, lässt sich beobachten, dass beide in das gleiche freie Segment aus $C$ gemergt werden. Wir müssen also die Threadnummern $j_A$ und $j_B$, bestimmen, die für $A_i$ und $B_i$ zuständig sind. Dann ist der Thread $j_A$ dafür zuständig $|A_i|$ Schritte von links zu mergen und der Thread $j_B$ ist dafür zuständig $|B_i|$ Schritte von rechts zu mergen. Wir setzen $d' = \lceil \frac{m+n}{p} \rceil$ als die Abstände zwischen den markierten Elementen und $r_A$ ist die rechte Grenze von $A_i$ und $r_B$ ist die rechte Grenze von $B_i$. Dann lässt sich $j_A$ berechnen durch $j_A = \lceil \frac{r_A}{d'} \rceil$ und $j_B$ durch $j_B = \lceil \frac{r_B}{d'}+m_A \rceil$, wobei $m_A$ die Anzahl der markierten Elemente in $A$ ist. Falls $r_A = |A|-1$, ist $A_i$ ein Segment, welches nicht durch ein markiertes Element abgeschlossen wird, und setzen $j_A = p-1$. Analog für $B$. \par
Nun können wir zum Schedule von Thread $j_A$ die Mergeaktion $(A_i, B_i, C_i, 0, |A_i|)$ und zum Schedule von Thread $j_B$ die Mergeaktion $(A_i, B_i, C_i, 1, |B_i|)$ hinzufügen. $C_i$ ist das Segment in $C$, in das $A_i$ und $B_i$ gemergt werden. Dieses lässt sich direkt aus den Segmentgrenzen von $A_i$ und $B_i$ bestimmen. \par
Im Beispiel betrachten wir die Subsegmente $[0,2)$ von $A$ und $[0,1)$ von $B$. Diese müssen in das freie Segment $[0,3)$ von $C$ gemergt werden. Es ergeben sich mit $d' = 3$ und $m_A = 2$ die Threadnummern $j_A = \lceil \frac{2}{3} \rceil = 0$ und $j_B = \lceil \frac{1}{3} \rceil + 2 = 2$. Also fügen wir zu Thread $0$ die Mergeaktion $([0,2), [0,1), [0,3), 0, 2)$ und zu Thread $2$ die Mergeaktion $([0,2), [0,1), [0,3), 1, 1)$ hinzu. Am Ende ergibt sich für jeden Thread das folgende Schedule: \par
$\begin{array}{ll}
\text{Thread 0:} & $[([0,2), [0,1), [0,3), 0, 2)]$ \\
\text{Thread 1:} & $[([3,5), [1,2), [4,7), 0, 2)]$ \\
\text{Thread 2:} & $[([0,2), [0,1), [0,3), 1, 1), ([3,5), [1,2), [4,7), 1, 1)]$ \\
\text{Thread 3:} & $[([6,7), [3,5), [9,12), 0, 1), ([6,7), [3,5), [9,12), 1, 2)]$ \\
\end{array}$

Im letzten Schritt müssen wir nun noch das berechnete Schedule aus Schritt sechs ausführen. Dazu iteriert jeder Thread über seine Liste der Mergeaktionen. Wenn er aktuell die Mergeaktion $(I_A, I_B, I_C, 0, l)$ betrachtet, führt er die ersten $l$ Mergeschritte, in der $I_A$ und $I_B$ in $I_C$ gemergt werden, von links aus, und wenn er die Mergeaktion $(I_A, I_B, I_C, 1, l)$ betrachtet, führt er die ersten $l$ Mergeschritte von rechts aus. \par
Im Beispiel enthält das Ausgabearray $C$ am Ende das korrekt gemergte Array:

\begin{table}[H]
	\small
	\centering
	\begin{tabular}{c| c c c c c c c c c c c c c c c c c}
		$i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
		$C[i]$ & 2 & 3 & 4 & 5 & 8 & 9 & 13 & 16 & 21 & 25 & 34 & 36 \\
	\end{tabular}
\end{table}