\subparagraph*{Theorem 7 - alles zusammen}

In diesem Abschnitt stellen wir einen parallelen Merge-Algorithmus vor, der effizient für eine konstante Anzahl an Threads $p$ arbeitet. Dieser Algorithmus wurde zuerst in \cite{merge:valiant} beschrieben und die Beschreibung wurde in \cite{merge:kruskal} weiter ergänzt. Dazu seien $\mathsf{A}$ und $\mathsf{B}$ die Eingabe-Arrays, die in das Ausgabe-Array $\mathsf{C}$ vereinigt werden sollen, mit $|\mathsf{A}|=n$, $|\mathsf{B}|=m$ und $|\mathsf{C}|=n+m$. \par
Wir werden den Algorithmus so erläutern, dass er mit einem beliebigen Vergleichsoperator arbeiten kann. Zur besseren Verständlichkeit verwenden wir in den Beispielen den Vergleichsoperator für natürliche Zahlen. In dem parallelen DC3 verwenden wir dann den bereits in \cref{dc3:algorithmus:phase3} beschriebenen Vergleichsoperator. 

Im Folgenden wird zunächst eine Übersicht über die Schritte des Algorithmus gegeben. Dieser Algorithmus arbeitet in sieben Schritten. In den ersten beiden Schritten werden insgesamt $p$ Elemente in $\mathsf{A}$ und $\mathsf{B}$ markiert und die Reihenfolge dieser Elemente in $\mathsf{C}$ werden durch Mergen bestimmt. Durch die Wahl der markierten Elemente werden $\mathsf{A}$ und $\mathsf{B}$ in einzelne Segmente aufgeteilt. Um die markierten Elemente an die korrekten Positionen in $\mathsf{C}$ schreiben zu können, benötigen wir für jedes markierte Element $x$ die Positionen in $\mathsf{A}$ und in $\mathsf{B}$. Diese Positionen werden in den Schritten drei und vier bestimmt und die markierten Elemente an die korrekten Positionen in $\mathsf{C}$ geschrieben. \par
In den letzten drei Schritten werden die übrigen Elemente in $\mathsf{A}$ und $\mathsf{B}$ vereinigt, indem zunächst die Subsegmente in $\mathsf{A}$ und $\mathsf{B}$ bestimmt werden, die an die freien Stellen in $\mathsf{C}$ vereinigt werden sollen. Diese werden dann mit der Pa\-ral\-le\-li\-sie\-rung aus \cref{dc3:erweiterung:parallel:mergezweiseiten} vereinigt.

Nun werden die einzelnen Schritte genauer beschrieben. Im ersten Schritt markieren wir höchstens $p$ Elemente in $\mathsf{A}$ und $\mathsf{B}$ in jeweils gleichen Abständen. Als Abstand $d$ setzen wir $d = \lceil \frac{m+n}{p} \rceil$ und die markierten Elemente $x_i$ sind dann an den Positionen $id-1$. \par
Markierte Elemente werden durch Tupel $(p_a, b, c)$ repräsentiert und in Arrays $\texttt{marked\_element\_A}$ geschrieben, wenn $x_i$ in $\mathsf{A}$ steht, bzw. $\texttt{marked\_element\_B}$, wenn $x_i$ in $\mathsf{B}$ steht. \par
Mit $p_a$ repräsentieren wir die Position des markierten Elements im Ursprungs-Array. $b$ ist ein Indikator, wobei $b = 0$, wenn $x_i$ in $\mathsf{A}$ steht und $b = 1$, wenn $x_i$ in $\mathsf{B}$ steht und $c$ repräsentiert die Nummer des markierten Elements im Urspungs-Array. Diese Werte werden benötigt, damit diese Informationen nach dem Mergen der markierten Elemente direkt bereit stehen. \par
In unserem Beispiel wollen wir die Arrays $\mathsf{A} = [2,3,5,8,13,21,34]$ und $\mathsf{B} = [4,9,16,25,36]$ mit vier Threads mergen. Der Abstand zwischen den Elementen ist $d = \frac{12}{4} = 3$. Wir markieren also in $\mathsf{A}$ die Elemente $5$ und $21$ und in $B$ das Element $16$. Abgespeichert als Tupel sehen die markierten Elemente wie folgt aus: \par
$\begin{array}{ll}
$\texttt{marked\_element\_A}$ = & $[(2,0,0), (5,0,1)]$ \\
$\texttt{marked\_element\_B}$ = & $[(2,1,0)]$ \\
\end{array}$

Im zweiten Schritt werden die markierten Elemente in $\texttt{marked\_element\_A}$ und in $\texttt{marked\_element\_B}$ in ein Array $\texttt{marked\_element}$ vereinigt. Dabei wird der Merge-Algorithmus für eine große Anzahl an Prozessoren verwendet. Da es höchstens $p$ markierte Elemente gibt, haben wir genug Prozessoren, um diesen Algorithmus verwenden zu können. \par
In unserem Beispiel werden $\texttt{marked\_element\_A}$ und $\texttt{marked\_element\_B}$ vereinigt und als Ausgabe ergibt sich $\texttt{marked\_element} = [(2,0,0), (2,1,0), (5,0,1)]$. Dies entspricht der sortierten Reihenfolge der markierten Elemente $[5,16,21]$.

Jetzt müssen wir zu jedem markierten Element $x$ die Positionen $p_A$ in $\mathsf{A}$ und $p_B$ in $\mathsf{B}$ bestimmen. Um die folgenden beiden Schritte einfacher beschreiben zu können, nehmen wir an, dass $x$ ein markiertes Element aus $\mathsf{A}$ ist. Für markierte Elemente aus $\mathsf{B}$ sind die Schritte analog. \par
Sei dazu $x$ ein markiertes Element aus $\mathsf{A}$. Die Position $p_A$ ist dann trivialerweise die Position an der $x$ in $\mathsf{A}$ steht. Dies haben wir an der ersten Stelle im Tupel von $x$ gespeichert. Um die Position $p_B$ bestimmen zu können, müssen wir in $\mathsf{B}$ nach der Position suchen, an der sich $x$ in $\mathsf{B}$ einordnen lässt. Damit wir uns eine Suche über das ganze Array $\mathsf{B}$ ersparen, nutzen wir die Ergebnisse aus Schritt zwei, um das Segment zu bestimmen, in dem wir weiter nach $x$ suchen. 
Dazu betrachten wir die sortierte Reihenfolge der markierten Elemente aus Schritt zwei. Weiterhin betrachten wir ein markiertes Element aus $\mathsf{B}$ der Form $x = (p_a, 1, c)$ und das darauf folgende markierte Element $x' = (p'_a, 1, c')$ aus $\mathsf{B}$. Wir beobachten, dass alle markierten Elemente $(q_a, 0, e)$ aus $\mathsf{A}$, die in der sortierten Reihenfolge zwischen $x$ und $x'$ stehen, im Segment zwischen den markierten Elementen $p_a$ und $p'_a$ in $\mathsf{B}$ eingeordnet werden müssen. Mit dieser Beobachtung können wir nun parallel die Segmente aus $\mathsf{B}$ bestimmen, in denen die markierten Elemente aus $\mathsf{A}$ vorkommen und umgekehrt. \par
Dazu erstellen wir zwei Hilfs-Arrays $pos_A$ und $pos_B$. In $pos_A$ speichern wir die Positionen der markierten Elemente in der sortierten Reihenfolge aus Schritt zwei und analog für $pos_B$. Da wir zu jedem markierten Element die Nummer in $\mathsf{A}$ bzw. $\mathsf{B}$ speichern, können wir $pos_A$ und $pos_B$ direkt bestimmen. Anschließend betrachten wir zwei direkt aufeinanderfolgende Elemente $x=(p_a, 1, c)$ und $x'=(p'_a, 1, c')$ in $pos_B$. Aus unserer Beobachtung können wir schließen, dass alle Elemente zwischen $x$ und $x'$ in der sortierten Reihenfolge aus Schritt zwei im Segment zwischen $p_a$ und $p'_a$ eingeordnet werden müssen. Daher können wir pa\-ral\-lel für jedes dieser Elemente das Segment $[p_a+1, p'_a)$ speichern. Analog lässt sich dieser Schritt für $pos_A$ durchführen. \par
In unserem Beispiel kommen die markierten Elemente von $\mathsf{A}$ in der sortierten Reihenfolge an den Positionen $0$ und $2$ vor und das markierte Element von $\mathsf{B}$ an der Position $1$. Also ist $pos_A = [0,2]$ und $pos_B = [1]$. Wir betrachten jetzt je zwei aufeinanderfolgende Elemente in $pos_A$, hier also $0$ und $2$. Dies bedeutet, dass in der sortierten Reihenfolge alle Elemente zwischen den Positionen $0$ und $2$ zum einen aus $\mathsf{B}$ kommen und dass diese im Segment zwischen den dazugehörigen markierten Elementen liegen. Also können wir schließen, dass das markierte Element $16$ im Segment $[3, 5)$ in $\mathsf{A}$ eingeordnet werden müsste. In $pos_B$ kommt nur das Element $1$ vor. Für alle Elemente, die davor oder dahinter in der sortierten Reihenfolge vorkommen, können wir dennoch das Segment bestimmen. Dazu ordnen wir dem ersten Element der sortierten Reihenfolge das Segment $[0,2)$ und dem letzten das Segment $[3,5)$ in $\mathsf{B}$ zu.

Im vierten Schritt können wir nun für jedes markierte Element in dem in Schritt drei bestimmten Segment eine binäre Suche durchführen um die Position $p_B$ zu erhalten. Diese Position wird in einem Array $\texttt{pos\_in\_other\_A}$ gespeichert, da wir diese Position im nächsten Schritt benötigen. Mit $p_A$ und $p_B$ lässt sich die Position der markierten Elemente in $\mathsf{C}$ durch $p_A+p_B$ berechnen. \par
Im Beispiel kommt das markierte Element $5$ in $\mathsf{A}$ an der Position $2$ vor. Mittels einer binären Suche im Segment $[0,2)$ in $\mathsf{B}$ können wir die Position $1$ berechnen, an der $5$ in $\mathsf{B}$ eingeordnet werden müsste. Also müssen wir $5$ in $\mathsf{C}$ an die Position $3$ schreiben. Das markierte Element $16$ steht in $\mathsf{B}$ an der Position $2$ und mit einer binären Suche bestimmen wir die Position $5$ an der $16$ in $\mathsf{A}$ eingeordnet werden müsste. In $\mathsf{C}$ steht die $16$ also an der Position $7$. Für das markierte Element lässt sich analog die Position $8$ in $\mathsf{C}$ berechnen. Unser Ausgabe-Array $\mathsf{C}$ sieht nach diesem Schritt also wie folgt aus:

\begin{table}[H]
	\small
	\centering
	\begin{tabular}{c| c c c c c c c c c c c c c c c c c}
		$i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
		$\mathsf{C}[i]$ & & & & 5 & & & & 16 & 21 & & & & \\
	\end{tabular}
\end{table}


Nach Schritt vier haben wir alle markierten Elemente an die korrekte Position in $\mathsf{C}$ geschrieben. Nun müssen wir noch alle übrigen Elemente mergen. Wir haben nun in $\mathsf{C}$ mehrere Segmente zwischen den markierten Elementen, die noch nicht beschrieben wurden. Wir beobachten, dass in einem freien Segment, welches durch $x$ und $x'$ induziert wird, nur diejenigen Elemente in $\mathsf{A}$ und $\mathsf{B}$ vorkommen können, die in $\mathsf{A}$ und $\mathsf{B}$ ebenfalls zwischen $x$ und $x'$ liegen. Durch die markierten Elemente und die in Schritt vier bestimmten Positionen der markierten Elemente im jeweils anderen Array ergibt sich somit eine Aufteilung in Subsegmente, die in ein freies Segment in $\mathsf{C}$ vereinigt werden sollen. \par
Im fünften Schritt werden wir also zunächst $\mathsf{A}$ und $\mathsf{B}$ in Subsegmente aufteilen. Dazu bestimmen wir zu Array $\mathsf{A}$ die Positionen der markierten Elemente $\texttt{pos\_marked\_A}$ und mergen dies mit $\texttt{pos\_in\_other\_B}$ mit dem Mergealgorithmus aus für eine große Anzahl an Prozessoren, um die Grenzen der Subsegmente zu erhalten. Daraus können wir die Subsegmente direkt bestimmen, da die Segmentgrenzen durch je zwei aufeinanderfolgende Positionen im vereinigten Array gegeben sind. Hier ist zu beachten, dass die markierten Elemente nicht in einem Subsegment enthalten sein dürfen. \par
Im Beispiel sind die markierten Elemente von $\mathsf{A}$ an den Positionen $[2,5]$ und das markierte Element $16$ von $\mathsf{B}$ wurde in $\mathsf{A}$ an die Position $[5]$ eingeordnet. Wenn wir beide Arrays mergen, ergibt sich das Array $[2,5,5]$, wobei die ersten beiden Elemente die markierten Elemente von $\mathsf{A}$ sind. Nun bestimmen wir die Subsegmente von $\mathsf{A}$. Dabei dürfen die markierten Elemente von $\mathsf{A}$ nicht in den Subsegmenten enthalten sein. Die Subsegmente sind also $[[0,2), [3,5), [6,7)]$. Analog ergeben sich die Subsegmente von $B$ als $[[0,1), [1,2), [3,5)]$.

Nun wollen wir die einzelnen Subsegmente aus $\mathsf{A}$ und $\mathsf{B}$ parallel mit dem in \cref{dc3:erweiterung:parallel:mergezweiseiten} beschriebenen Algorithmus in die richtigen Segmente in $\mathsf{C}$ mergen. Unser Ziel ist es, dass jeder Thread möglichst gleich viele Schritte beim Mergen benötigt. Dazu übernimmt jeder Thread ein Segment der Größe höchstens $s \le \lceil \frac{m+n}{p} \rceil$ in $\mathsf{A}$ und $\mathsf{B}$ und ist dafür zuständig $s$ Elemente zu mergen. Falls es in $\mathsf{A}$ und $\mathsf{B}$ Segmente gibt, die nicht durch ein markiertes Element beendet werden, werden beide von einem Thread übernommen. \par
Wir berechnen zunächst für jeden Thread ein \textit{Schedule}. Ein Schedule ist eine Liste von \textit{Merge-Aktionen}, die festlegen, welche Subsegmente vereinigt werden und ob diese von links oder rechts vereinigt werden sollen. Genauer ist eine Merge-Aktion ein Tupel $(\mathsf{I}_A, \mathsf{I}_B, \mathsf{I}_C, d, l)$, wobei $\mathsf{I}_A$ ein Subsegment aus $\mathsf{A}$, $\mathsf{I}_B$ ein Subsegment aus $B$ und $\mathsf{I}_C$ ein freies Segment in $\mathsf{C}$ ist, in das $\mathsf{I}_A$ und $\mathsf{I}_B$ vereinigt werden sollen. $d$ ist ein Indikator, wobei $d = 0$, wenn die Merge-Schritte von links, und $d = 1$, wenn die Merge-Schritte von rechts ausgeführt werden sollen. $l$ bezeichnet die Anzahl der Merge-Schritte, die ausgeführt werden sollen. \par
Nun beschreiben wir, wie ein solches Schedule berechnet werden kann. Wenn wir das $i$-te Subsegment $\mathsf{A}_i$ und $\mathsf{B}_i$ aus $\mathsf{A}$ und $\mathsf{B}$ betrachten, lässt sich beobachten, dass beide in das gleiche freie Segment aus $\mathsf{C}$ vereinigt werden. Wir müssen also die Thread-Nummern $j_A$ und $j_B$ bestimmen, die für $\mathsf{A}_i$ und $\mathsf{B}_i$ zuständig sind. Dann ist der Thread $j_A$ dafür zuständig $|\mathsf{A}_i|$ Schritte von links zu mergen und der Thread $j_B$ ist dafür zuständig $|\mathsf{B}_i|$ Schritte von rechts zu mergen. Wir setzen $d' = \lceil \frac{m+n}{p} \rceil$ als Abstand zwischen den markierten Elementen und $r_A$ ist die rechte Grenze von $\mathsf{A}_i$ und $r_B$ ist die rechte Grenze von $\mathsf{B}_i$. Dann lässt sich $j_A$ berechnen durch $j_A = \lfloor \frac{r_A}{d'} \rfloor$ und $j_B$ durch $j_B = \lfloor \frac{r_B}{d'}+m_A \rfloor$, wobei $m_A$ die Anzahl der markierten Elemente in $\mathsf{A}$ ist. Falls $r_A = |\mathsf{A}|-1$, ist $\mathsf{A}_i$ ein Segment, welches nicht durch ein markiertes Element abgeschlossen wird, und setzen $j_A = p-1$. Analog für $\mathsf{B}$. \par
Nun können wir für Thread $j_A$ die Merge-Aktion $(\mathsf{A}_i, \mathsf{B}_i, \mathsf{C}_i, 0, |\mathsf{A}_i|)$ und für Thread $j_B$ die Merge-Aktion $(\mathsf{A}_i, \mathsf{B}_i, \mathsf{C}_i, 1, |\mathsf{B}_i|)$ zum Schedule hinzufügen. $\mathsf{C}_i$ ist das Segment in $\mathsf{C}$, in das $\mathsf{A}_i$ und $\mathsf{B}_i$ vereinigt werden. Dieses lässt sich direkt aus den Segmentgrenzen von $\mathsf{A}_i$ und $\mathsf{B}_i$ bestimmen. \par
Im Beispiel betrachten wir die Subsegmente $[0,2)$ von $\mathsf{A}$ und $[0,1)$ von $\mathsf{B}$. Diese müssen in das freie Segment $[0,3)$ von $\mathsf{C}$ vereinigt werden. Es ergeben sich mit $d' = 3$ und $m_A = 2$ die Thread-Nummern $j_A = \lfloor \frac{2}{3} \rfloor = 0$ und $j_B = \lfloor \frac{1}{3} \rfloor + 2 = 2$. Also fügen wir zu Thread $0$ die Merge-Aktion $([0,2), [0,1), [0,3), 0, 2)$ und zu Thread $2$ die Merge-Aktion $([0,2), [0,1), [0,3), 1, 1)$ hinzu. Am Ende ergibt sich für jeden Thread das folgende Schedule: \par
$\begin{array}{ll}
\text{Thread 0:} & $[([0,2), [0,1), [0,3), 0, 2)]$ \\
\text{Thread 1:} & $[([3,5), [1,2), [4,7), 0, 2)]$ \\
\text{Thread 2:} & $[([0,2), [0,1), [0,3), 1, 1), ([3,5), [1,2), [4,7), 1, 1)]$ \\
\text{Thread 3:} & $[([6,7), [3,5), [9,12), 0, 1), ([6,7), [3,5), [9,12), 1, 2)]$ \\
\end{array}$

Im letzten Schritt müssen wir nun noch das berechnete Schedule aus Schritt sechs ausführen. Dazu iteriert jeder Thread über seine Liste der Merge-Aktionen. Wenn er aktuell die Merge-Aktion $(\mathsf{I}_A, \mathsf{I}_B, \mathsf{I}_C, 0, l)$ betrachtet, führt er die ersten $l$ Merge-Schritte, in der $\mathsf{I}_A$ und $\mathsf{I}_B$ in $\mathsf{I}_C$ vereinigt werden, von links aus, und wenn er die Merge-Aktion $(\mathsf{I}_A, \mathsf{I}_B, \mathsf{I}_C, 1, l)$ betrachtet, führt er die ersten $l$ Merge-Schritte von rechts aus. \par
Im Beispiel enthält das Ausgabe-Array $\mathsf{C}$ am Ende das korrekt vereinigte Array:

\begin{table}[H]
	\small
	\centering
	\begin{tabular}{c| c c c c c c c c c c c c c c c c c}
		$i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
		$\mathsf{C}[i]$ & 2 & 3 & 4 & 5 & 8 & 9 & 13 & 16 & 21 & 25 & 34 & 36 \\
	\end{tabular}
\end{table}