\section{DivSufSort}
\label{algorithm:divsufsort}

\subsection{Einleitung}
In \currentauthor{Oliver Magiera} vielen Bereichen der Algorithmik sind Laufzeiten der entscheidende Faktor beim Vergleich von Algorithmen. Dabei werden bei den Analysen zumeist eher theoretische worst-case Laufzeitschranken betrachtet.
In der Praxis hingegen können die Ergebnisse anders aussehen. Ein bedeutendes Beispiel ist dabei der \glqq DivSufSort\grqq{} von Y. Mori \cite{saca:5:repo}. Mit einer worst-case Laufzeit von $O(n\log{n})$ und einem Speicherbedarf von $5n + O(1)$ mit $n$ als Textlänge liefert der Algorithmus bereits gute Schranken, jedoch nicht die Besten. In der Praxis hingegen liegt mit diesem Algorithmus eine der schnellsten Berechnungen für Suffixarrays vor. Da Y. Mori den Algorithmus nur als (kaum kommentierten) Quellcode veröffentlicht hat, werden wir im Folgenden den Algorithmus anhand der Beschreibung von J. Fischer und F. Kurpicz \cite{saca:5} erläutern. Dafür werden wir uns zunächst die zugrunde liegenden Algorithmen im Abschnitt Grundlagen anschauen, bevor wir uns den Definitionen und einigen Vorüberlegungen zu Suffix Arrays widmen. Danach beschreiben wir den eigentlichen Algorithmus, bevor wir die Ausarbeitung abschließen.

\iffalse
\subsection{Grundlagen}
Da einige bereits vorhandene Algorithmen und Berechnungen im DivSufSort-Algorithmus verwendet werden, sollen diese zunächst näher erläutert werden. Dafür beginnen wir mit der Präfixsumme.


\subsubsection{Heapsort}
Heapsort basiert auf der Struktur von Heaps, einem speziellen Binärbaum mit Heap-Bedingung. Bei Max-Heaps ist jeder Knoten größer als seine Kindknoten (Heap-Bedingung). Ein Heap kann auch als Array betrachtet werden. Dabei sind die Kinder eines Knotens $i$ die Knoten $2i$ und $2i + 1$. Ein Elter kann entsprechend erreicht werden über $\lfloor i/2 \rfloor$. Eine wichtige Operation für Heaps ist \textit{Max-Heapify}. Für einen gegebenen Knoten $i$ sei die Heap-Bedingung nicht erfüllt. Dann tauschen wir $i$ so lange mit dem größeren seiner Kinder, bis die Heap-Bedingung erfüllt ist. \textit{Build-Max-Heap} funktioniert wie folgt: Führe für alle Knoten, welche keine Blätter sind, \textit{Max-Heapify} aus, d.h. von $\lfloor \text{length}[H]/2\rfloor$ bis 1 (H bezeichnet Array für den Heap).

Heapsort läuft nun wie folgt ab: Erzeuge einen Max-Heap über \textit{Build-Max-Heap}. Die Wurzel enthält das größte Element, daher tausche es mit dem $n$-ten aus und verkleinere den Heap um 1. Führe daraufhin \textit{Max-Heapify} auf und wiederhole die Schritte, bis nur noch zwei Knoten vorhanden sind \cite{Cormen2009}[Kapitel 6].

\subsection{Quicksort}
Ein sehr beliebtes Verfahren Dank seiner Schnelligkeit ist Quicksort. Die Idee ist dabei simpel: Partitioniere ein (Teil-)Array anhand eines Pivotelements. Links von dem Pivot sind alle Elemente kleiner als das Pivot, rechts davon alle, die größer als das Pivot sind. Führe rekursiv Quicksort für die Teilarrays links und rechts vom Pivot aus. Das Partitionieren kann dabei wie folgt durchgeführt werden: Durchlaufe das Array von links nach rechts. Suche nach einem Element, welches kleiner gleich dem Pivot (letztes Element im Array) ist . Ist dieses gefunden, tausche es mit dem ersten Element, welches größer ist als das Pivot (über verwalteten Pointer). Wiederhole bis das vorletzte Element geprüft wurde. Der verwaltete Pointer gibt den Index an, welcher auf die Trennung der beiden Partitionen zeigt \cite{Cormen2009}[Kapitel 7].

\subsection{Multikey Quicksort}
Multikey Quicksort ist eine Erweiterung des Quicksort, welches ermöglicht, Elemente mit mehreren Schlüsseln wie Strings zu sortieren. Dabei geht der Algorithmus wie folgt vor: Verwalte eine Referenz zur aktuellen Tiefe $k$. Diese Referenz repräsentiert, nach welchem Zeichen aktuell sortiert wird. Alle Elemente kleiner als das Pivot landen im linken Teilarray und alle Elemente größer als das Pivot landen im rechten Teilarray, d.h. das $k$-te Zeichen wird jeweils verglichen. In diesen Teilarrays wird erneut mittels Multikey Quicksort nach dem $k$-ten Zeichen sortiert. Alle Elemente, deren $k$-tes Zeichen dem des Pivots gleicht, landen im mittleren Teilarray. Dieses Teilarray wird mittels Multikey Quicksort nach Zeichen $k+1$-sortiert \cite{bese97}. 

\subsection{Introspective Sort}
Zuletzt betrachten wir einen Sortieralgorithmus, welcher Quicksort mit Heapsort und Insertionsort kombiniert. Dabei verwenden wir eine spezielle Form des Quicksort, den Median-of-3 Quicksort. Um das Pivotelement zu bestimmen, betrachtet man das erste, das mittlere und das letze Element im betrachteten Array. Wir wählen davon den Median als Pivot. Nun Partitionieren wir das Array mittels berechnetem Pivot und sortieren erst das rechte, dann das linke Teilarray mittels Introspective Sort. Es gibt jedoch zwei Ausnahmen, wo wir kein Quicksort verwenden. Zum einen sortieren wir ab einer bestimmten Tiefe mittels Heapsort. Die maximale Tiefe ist dabei beschränkt durch $\lfloor \lg (last - first) \rfloor$, d.h. der Logarithmus von der Länge des ursprünglichen Arrays, abgerundet. Dies soll dafür sorgen, dass bei sogenannten Median-of-3 \glqq Killer-Sequenzen\grqq{}, das sind Sequenzen, welche die am schlechtesten Mögliche Eingabe für den Quicksort enthalten, die Laufzeit des Quicksort nicht $\Theta (n^2)$ beträgt. Zum anderen existiert ein Schwellwert (z.B. 8), welcher dafür sorgen soll, dass bei besonders kleinen Intervallen kein zu großer Overhead durch Quicksort bzw Heapsort entsteht. Fällt die Größe des betrachteten (Teil-)Arrays nämlich unterhalb dieses Schwellwerts, so wird Insertionsort angewandt. Die Prüfung auf den Schwellwert ist dabei die äußerste Schleife des Sortierverfahrens \cite{Musser97}.

\fi

\input{kapitel/saca_algorithmen/dss/grundlagen.tex}

\subsection{Der DivSufSort-Algorithmus}

Der Algorithmus selbst kann in drei Phasen unterteilt werden. In der ersten Phase müssen zunächst den Suffixen ihre Typen zugewiesen werden. Dafür muss der Text ein Mal durchlaufen werden. Während dieses Durchlaufes werden ebenfalls die Grenzen für die Buckets $b_{c0}$ bzw. $b_{c0,c1}$ berechnet. In Phase zwei werden die RMS-Suffixe in lexikografischer Reihenfolge sortiert und bereits an die korrekten Positionen im Suffix-Array \textit{SA} gesetzt. Hierfür werden zunächst die RMS-Teilstrings sortiert und deren Ränge bestimmt. Mit diesen Rängen können letztlich die RMS-Suffixe sortiert werden. In der dritten und letzten Phase müssen noch die L- und S-Suffixe an ihre richtigen Positionen gebracht werden. Dafür werden in einem Durchlauf von rechts nach links erst alle S-Suffixe und in einem zweiten Durchlauf von links nach rechts alle L-Suffixe induziert.

Damit diese drei Schritte reibungslos ablaufen können, benötigen wir noch etwas zusätzlichen Speicher. Wir verwenden zwei zusätzliche Arrays \textit{BUCK\-ET\_L} für L-Suffixe und \textit{BUCK\-ET\_S} für S- und RMS-Suffixe, um Informationen über die Buckets abspeichern zu können. \textit{BUCK\-ET\_L} der Größe $\sigma = |\Sigma |$ wird über einen Character $c0$ abgerufen, \textit{BUCK\-ET\_S} der Größe $\sigma ^2$ hingegen über zwei Character $(c0,c1)$. Um zwischen Referenzen für S- und RMS-Suffixen zu unterscheiden, werden diese über \textit{BUCK\-ET\_S$[c0,c1] = $ BUCK\-ET\_S$[|c0| \cdot \sigma + |c1|]$} bzw. \textit{BUCK\-ET\_RMS$[c0,c1] = $ BUCK\-ET\_S$[|c1| \cdot \sigma + |c0|]$} abgerufen. Die Buckets für S- und RMS-Suffixe können in demselben Array abgespeichert werden, da in $b_{c0,c0}$ keine RMS-Suffixe und in $b_{c0,c1}$ mit $c0 > c1$ keine S-Suffixe enthalten sein können. Die Anzahl der RMS-Suffixe wird mit $m$ bezeichnet.

Kommen wir nun zur ersten Phase des Algorithmus, der Initialisierung.
\input{kapitel/saca_algorithmen/dss/initialisierung.tex}
\input{kapitel/saca_algorithmen/dss/rms-suffixe.tex}
\input{kapitel/saca_algorithmen/dss/induzieren.tex}
\input{kapitel/saca_algorithmen/dss/implementierung.tex}

%TODO: Zusammenfassung überarbeiten
\subsection{Zusammenfassung}
Wir haben einen der schnellsten Algorithmen in der Praxis zur Konstruktion von Suffix-Arrays kennen gelernt. Neben der Unterteilung in L-, S-, und RMS-Suffixe nutzt der Algorithmus auch die Verteilung dieser in den jeweiligen Buckets aus. In der ersten Phase haben wir zunächst die Größen der Buckets gezählt, die RMS-Suffixe sowie ihre relative Positionierung im Text ins Suffix-Array eingetragen und über die Präfixsummen die Grenzen der jeweiligen Buckets berechnet. In der zweiten Phase haben wir erst die RMS-Teilstrings der einzelnen Buckets $b_{c0,c1}$ mithilfe des Introspective Sorts sortiert, daraufhin das partielle inverse Suffix-Array bestimmt und mit den Rängen des ISA und dem Doppeln der RMS-Substrings die RMS-Suffixe mit einem ähnlichen Verfahren zum Introspective Sort korrekt sortiert. In der letzten Phase haben wir zuerst in einem Durchlauf durch die Ausnutzung der Ordnung innerhalb einzelner Buckets von rechts nach links alle S-Suffixe induziert, in einem zweiten Durchlauf von links nach rechts dann auch die l-Suffixe, was zum korrekt sortierten Suffix-Array führt. 



\iffalse
% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
	\begin{tabular}{l|lllllllllllllll}
		i  & 0 & 1 & 2                & 3               & 4 & 5                         & 6                         & 7                                        & 8                                       & 9 & 10 & 11 & 12 & 13 & 14 \\ \hline
		T  & c & a & a                & b               & a & c                         & c                         & a                                        & a                                       & b & a  & c  & a  & a  & \$ \\ \hline
		SA & 8 & 2 & $\widetilde{10}$ & $\widetilde{4}$ & 1 & 3                         & 0                         & 2                                        & 0                                       & 0 & 0  & 2  & 4  & 8  & 10 \\ \hline
		SA & 8 & 2 & $\widetilde{10}$ & $\widetilde{4}$ & 1 & \cellcolor[HTML]{32CB00}8 & \cellcolor[HTML]{32CB00}2 & \cellcolor[HTML]{32CB00}$\widetilde{10}$ & \cellcolor[HTML]{32CB00}$\widetilde{4}$ & 0 & 0  & 2  & 4  & 8  & 10
	\end{tabular}
	\caption{Setzen der RMS-Suffixindizes an die richtige Position in \textbf{SA}.}
\end{table}
\fi

