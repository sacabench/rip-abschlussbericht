\chapter{Extended Abstract}

% ###
% Beginning of the extended abstract. We will use english in this chapter.
\selectlanguage{english}
% ###

\section{Introduction}

The \currentauthor{Marvin BÃ¶cker} \emph{suffix array} (\emph{SA}) is a widely known text index,
which can be used for various string operations,
like full-text search~\cite{makinen} and construction of the Burrows-Wheeler Transform (BWT)~\cite{BWT}.
While the efficient construction is still an active research area,
divsufsort~\cite{saca:5,saca:5:repo} is the empirically fastest suffix array construction algorithm (SACA) since 2008\todo{wann?},
even though it has a theoretical complexity of $\mathcal O (n \log n)$,
while there are some $\mathcal O(n)$ algorithms available.
For the last year we (re-)implemented eleven SACAs~\cite{saca:3,saca:11,saca:5,saca:9,saca:1,saca:8,saca:4,saca:7,saca:10,saca:6,saca:2} in modern C++ in order to beat divsufsort from its throne,
and although our attempts were not successful,
we created a sophisticated benchmark system for SACA algorithms, \emph{SACABench}, in the process.

In this paper we introduce SACABench and highlight its features,
as well as document some of the optimiziation strategies we used to implement the SACA algorithms. \blindtext

\section{Benchmark Tool}

SACABench is a CMake/C++14 project which contains many different SACA algorithms.
There are both sequential algorithms and parallel algorithms included and we also include the reference implementations for all of the algorithms, if there is one.
You are able to run a single, a subset of, or all of the algorithms, depending on your needs.
Time and memory consumption is automatically measured and can be output as JSON.
We also include tools to convert the JSON-format to graphs for a visual comparison of the algorithms.
Most of the graphs in this paper have been generated using SACABench directly\todo{Is that so?}.

\section{SACA Overview}

There are many SACAs that operate using different principles.
The most na\"ive SACA uses a general purpose string-sorter to sort the suffices of the input text.
Since a string comparison is $\mathcal O (n)$ in the worst-case, this would give $\mathcal O (n^2 \log n)$ runtime.
Even though this is a sub-optimal time bound,
there are several algorithms\footnote{These are Deep-Shallow, ...} in SACABench which don't improve on this,
but rather use methods to speed up the real-world performance.
These methods can be classified into the categories \emph{inducing} and \emph{doubling}:
%
\paragraph{Inducing} When you know the \emph{rank} of the suffix $i$, that is the position of $i$ in the SA, you also know the rank of the suffix $i-1$, if it is a L-Type.\todo{fixme. introduce L-types beforehand and fix this explaination}
\paragraph{Doubling} Imagine radix-sort, but with double the block size everytime. \todo{fix}

\bigskip

\blindtext

\section{Optimization Strategies}
\subsection{Different bit lengths for the suffix array}

We implemented our SACAs with an exchangable suffix array index type, that is a different bit length for the indices in the suffix array.
With our current implementation it is possible to use 32, 40, 48 and 64 bit for the suffix array elements.
Since our tool supports a different output encoding (32 or 64 bit), we can save memory during construction regardless of the desired output length.
Keep in mind that since the 40- and 48-bit types are not standardized, their performance is inferior to those of 32- and 64- bit types.
We measured an approximate 2.5x slowdown compared to the built-in number types.\todo{Nochmal richtig messen?}

\subsection{Cache-efficiency}

The most crucial part of optimizing a SACA is cache-efficiency, that is aiming for time-local and space-local memory access.
Since the SA is a pseudo-random mutation of numbers, the SA can't be written cache-efficiently.

\subsection{Wordpacking}

To maximize throughput, multiple characters of the input (8 bit each) can be processed as a whole by interpreting them as integer numbers (64 bit, or even up to 512 bit).
This is done in multiple algorihms\todo{welche?} to improve performance.

\subsection{Binary vs. ternary comparison-based sort}

Since different applications require different algorithms, we implemented multiple versions of quicksort:
Two of them are introsort~\cite{Musser97} and ternary quicksort~\cite{ternary_quicksort}.
It has been shown, that the binary sorting procedure is faster, if there are no equal elements in the set to be sorted.\todo{Graph oder Messung?}
The ternary version is faster when there are~\cite{ternary_quicksort}.
We therefore chose the best option for the required use-case.

\section{Conclusion}

We introduced SACABench, an extensible framework for comparing suffix array construction algorithms,
which already contains many implemented SACAs.


\blindtext

\blindtext

% ###
% End of extended abstract, switch language to german again
\selectlanguage{ngerman}
% ###
